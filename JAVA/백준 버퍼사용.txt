1번 숫자의 개수
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
 
	public static void main(String[] args) throws IOException {
		
		 BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		 // scanner보다 우월한 성능을 지니고 있다 BufferedReader
		 
		 int [] arr = new int[10];
		 // 먼저 0부터 9까지 체크할 길이 10의 int배열을 생성 (기본 int배열 초기값은 모두 0이다.)
		 
		 int val = Integer.parseInt(br.readLine()) * Integer.parseInt(br.readLine()) * Integer.parseInt(br.readLine());
		 // val에다가 br.readLine()으로 읽은 값을 곱해서 저장한다. 
		 
		 String str = String.valueOf(val);
		 // val의 int형을 string형으로 변환해준 뒤 
		 // 해당 문자열의 문자 값 -48 또는 -0을 추출해내 int배열의 index값을 1증가시킨다.
		 // charAt()을 쓸경우 -'0' 또는 -48을 연산해야 한다. 아니면 아스키코드에 대응하는 문자가 나온다.
		 // string으로 저장된 문자열 중에서 한 글자만 선택해서 char타입을 변환해주는 녀석이다. 
		 
		for(int i=0; i < str.length(); i++) {
			 
			 arr[(str.charAt(i) - 48)]++;
		 }
		 
		 for(int v : arr) {
			 System.out.println(v);
		 }
	}
}

2번 나머지 [HashSet 사용]

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashSet;

public class Main {
 
	public static void main(String[] args) throws IOException {
		
		 BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		 HashSet<Integer> h = new HashSet<Integer>();
		 
		 for(int i =0; i < 10; i++) {
			 h.add(Integer.parseInt(br.readLine()) % 42);
			 
			 // 입력받은 값의 나머지 값을 add메소드를 통해 HashSet에 저장 
			 // 이 때 HashSet<Integer>으로 타입을 선언했기 때문에 int형 또는 Integer객체를 넣어주어야한다.
			 // 또한 이 메소드에서 값을 넣을 때 만약 중복되는 값이 없으면 HashSet에 저장되면서 True를 반환
			 // 만약 중복되어 저장되지 않으면 False를반환한다.
		 }
		 
		 System.out.println(h.size());
		 // HashSet의 크기(size)는 저장되어 있는 원소의 개수를 반환한다. 
		 		 
	}
}

3번 평균 

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;


public class Main {
 
	public static void main(String[] args) throws IOException {
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		 
		double arr [] = new double[Integer.parseInt(br.readLine())];
		// double한 이유는 ? 문제에 오차범위가 있기 때문에 
		// 반드시 연산 할 때 최소한 자료형 1개 이상은 double형으로 써야한다. 
		// 그러면 자동형변환이 되면서 큰 쪽으로 (int에서 double)변환이 되기 때문이다.
		
		StringTokenizer st = new StringTokenizer(br.readLine(), " ");
		// BufferedReader은 공백까지 한 줄로 한 번에 받기 때문에 반드시 문자열 분리를 해주어야 한다 
		// 문자열 분리를 위해 StringTokenizer를 사용 
		
		for(int i =0; i < arr.length; i++) {
			arr[i] = Double.parseDouble(st.nextToken());
			// st는 문자열 
			// stirng에서 double형으로 바꾸려면 Double.parseDouble()을 사용해야한다. 
		}
		double sum = 0;
		Arrays.sort(arr);
		
		for(int i = 0; i < arr.length; i++) {
			sum += ((arr[i] / arr[arr.length - 1]) * 100);
		}
		System.out.println(sum / arr.length);
		}
	}